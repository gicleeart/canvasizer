name: Artwork to AR (GLB + USDZ)

on:
  repository_dispatch:
    types: [canvasizer_trigger]

permissions:
  contents: write # allow pushes to main

jobs:
  build-ar:
    runs-on: macos-latest
    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Cache Blender
        uses: actions/cache@v3
        with:
          path: blender
          key: blender-macos-4.2.0

      - name: Download Blender if not cached
        run: |
          mkdir -p blender
          if [ ! -f blender/Blender.app/Contents/MacOS/Blender ]; then
            echo "‚¨áÔ∏è Downloading Blender 4.2.0..."
            curl -L https://mirror.clarkson.edu/blender/release/Blender4.2/blender-4.2.0-macos-x64.dmg -o blender/blender.dmg
            hdiutil attach blender/blender.dmg -mountpoint /Volumes/Blender
            cp -R "/Volumes/Blender/Blender.app" blender/
            hdiutil detach /Volumes/Blender
          else
            echo "‚úÖ Blender already cached"
          fi
          
      - name: Cache USD repo
        uses: actions/cache@v3
        with:
          path: USD
          key: usd-repo-${{ runner.os }}-${{ hashFiles('USD/.git/HEAD') }}
          restore-keys: |
            usd-repo-${{ runner.os }}-

      - name: Clone USD if not cached
        run: |
          if [ ! -d "USD" ]; then
            git clone --depth 1 https://github.com/PixarAnimationStudios/USD.git
          fi

      - name: Cache USD build
        uses: actions/cache@v3
        with:
          path: ${{ github.workspace }}/usd-tools
          key: usd-build-${{ runner.os }}-${{ hashFiles('USD/build_scripts/build_usd.py') }}
          restore-keys: |
            usd-build-${{ runner.os }}-

      - name: Build USD tools if not cached
        run: |
          if [ -f "${{ github.workspace }}/usd-tools/bin/usdzip" ]; then
            echo "‚úÖ USD tools already built"
          else
            cd USD
            python build_scripts/build_usd.py ${{ github.workspace }}/usd-tools --no-usdview --no-tests --no-imaging
          fi

      - name: Download artwork from WordPress
        run: |
          mkdir -p assets scripts output
          curl -L "${{ github.event.client_payload.image_url }}" -o assets/artwork.png
      
      - name: Set User ID as an environment variable
        run: echo "USER_ID=${{ github.event.client_payload.user_id }}" >> $GITHUB_ENV

      - name: Create Blender Python script
        run: |
          cat > scripts/make_ar_plane.py << 'PY'
          import bpy
          import os
          import math
          # === 1. SETUP ===
          img_path = os.environ["ARIP_IMAGE_PATH"]
          out_glb  = os.environ["ARIP_OUT_GLB"]
          out_usdz = os.environ["ARIP_OUT_USDZ"]
          os.makedirs(os.path.dirname(out_glb), exist_ok=True)
          os.makedirs(os.path.dirname(out_usdz), exist_ok=True)
          bpy.ops.wm.read_factory_settings(use_empty=True)
          # === 2. GEOMETRY AND IMAGE LOADING ===
          img = bpy.data.images.load(img_path)
          img.colorspace_settings.name = "sRGB"
          width_m = 1.50
          depth_m = 0.02
          aspect_ratio = (img.size[0] / img.size[1]) if img.size[1] > 0 else 1.0
          height_m = width_m / aspect_ratio
          bpy.ops.mesh.primitive_plane_add(size=1.0, enter_editmode=False, location=(0, 0, 0))
          panel = bpy.context.active_object
          panel.name = "ArtPanel"
          mod = panel.modifiers.new(name="Solidify", type='SOLIDIFY')
          mod.thickness = depth_m
          mod.offset = 1.0
          bpy.ops.object.modifier_apply(modifier=mod.name)
          panel.scale = (width_m / 2.0, height_m / 2.0, 1.0)
          bpy.ops.object.transform_apply(scale=True)
          panel.rotation_euler[0] = math.radians(90)
          bpy.ops.object.transform_apply(rotation=True)
          # === 3. MATERIAL SETUP ===
          mesh = panel.data
          mat_artwork = bpy.data.materials.new("ArtworkMaterial")
          mat_artwork.use_nodes = True
          nodes = mat_artwork.node_tree.nodes
          bsdf = nodes.get("Principled BSDF")
          tex_node = nodes.new("ShaderNodeTexImage")
          tex_node.image = img
          mat_artwork.node_tree.links.new(tex_node.outputs['Color'], bsdf.inputs['Base Color'])
          mesh.materials.append(mat_artwork)
          # === 4. EXPORT LOGIC ===
          bpy.ops.object.select_all(action='DESELECT')
          panel.select_set(True)
          bpy.context.view_layer.objects.active = panel
          print(f"üì¶ Exporting GLB to {out_glb}...")
          bpy.ops.export_scene.gltf(filepath=out_glb, export_format='GLB', use_selection=True, export_yup=True)
          print("‚úÖ GLB export complete.")
          print(f"üì¶ Exporting USDZ to {out_usdz}...")
          bpy.ops.wm.usd_export(filepath=out_usdz, selected_objects_only=True, export_textures=True, relative_paths=False)
          print("‚úÖ USDZ export complete.")
          PY
      
      - name: Run Blender to generate 3D models
        env:
          ARIP_IMAGE_PATH: ${{ github.workspace }}/assets/artwork.png
          ARIP_OUT_GLB: ${{ github.workspace }}/output/model-${{ github.event.client_payload.post_id }}.glb
          ARIP_OUT_USDZ: ${{ github.workspace }}/output/model-${{ github.event.client_payload.post_id }}.usdz
        run: blender/blender.app/Contents/MacOS/Blender -b -noaudio --python scripts/make_ar_plane.py
      
      - name: Normalize and stage artifacts
        run: |
          set -e
          mkdir -p "public_models/${{ env.USER_ID }}"
          shopt -s nullglob nocaseglob
          files=(output/*.{glb,usdz})
          if [ ${#files[@]} -eq 0 ]; then
            echo "‚ùå No 3D model files were produced in the 'output' folder. Aborting."
            exit 1
          fi
          for f in "${files[@]}"; do
            base=$(basename "$f")
            lower=$(echo "$base" | tr '[:upper:]' '[:lower:]')
            cp -v "$f" "public_models/${{ env.USER_ID }}/$lower"
          done
          echo "‚úÖ Models staged in public_models/${{ env.USER_ID }}/:"
          ls -la "public_models/${{ env.USER_ID }}"

      - name: Commit artifacts to repository
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "public_models/${{ env.USER_ID }}"
          git commit -m "Add AR models for ${{ github.event.client_payload.title }} (user: ${{ env.USER_ID }})" || echo "No changes to commit."
          git push

      - name: POST back to WordPress (after HEAD check)
        env:
          WP_WEBHOOK_URL: ${{ secrets.WP_WEBHOOK_URL }}
          WP_WEBHOOK_TOKEN: ${{ secrets.WP_WEBHOOK_TOKEN }}
        run: |
          # This command ensures the script will exit immediately if any command fails.
          set -e

          # 1. Construct the paths to the generated model files.
          # The ${{...}} variables are replaced by GitHub before the script runs.
          GLB_PATH="public_models/${{ env.USER_ID }}/model-${{ github.event.client_payload.post_id }}.glb"
          USDZ_PATH="public_models/${{ env.USER_ID }}/model-${{ github.event.client_payload.post_id }}.usdz"

          # 2. Initialize the URL variables as empty strings.
          GLB_URL=""
          USDZ_URL=""

          # 3. If the GLB file exists in the repo, build its full public URL.
          if [ -f "$GLB_PATH" ]; then
            GLB_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/${GLB_PATH}"
          fi

          # 4. If the USDZ file exists, build its full public URL.
          if [ -f "$USDZ_PATH" ]; then
            USDZ_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/${USDZ_PATH}"
          fi

          # 5. Log the final URLs for debugging in the Actions console.
          echo "---"
          echo "Will POST with:"
          echo "GLB: $GLB_URL"
          echo "USDZ: $USDZ_URL"
          echo "---"

          # 6. Wait for the files to be available on the GitHub CDN.
          # This loop tries up to 10 times to verify the GLB URL is live.
          for i in {1..10}; do
            if curl --silent --head --fail "$GLB_URL" > /dev/null; then
              echo "‚úÖ GLB is live"
              break
            fi
            echo "‚è≥ Waiting for GLB to propagate (attempt $i)..."
            sleep 3
          done

          # 7. Post the final data back to the WordPress webhook.
          # The 'jq' command safely builds the JSON payload.
          jq -n \
            --arg post_id "${{ github.event.client_payload.post_id }}" \
            --arg user_id "${{ github.event.client_payload.user_id }}" \
            --arg title "${{ github.event.client_payload.title }}" \
            --arg glb "$GLB_URL" \
            --arg usdz "$USDZ_URL" \
            '{post_id: $post_id, user_id: $user_id, title: $title, glb_url: $glb, usdz_url: $usdz}' \
          | curl --verbose --request POST "$WP_WEBHOOK_URL" \
            --header "Authorization: Bearer $WP_WEBHOOK_TOKEN" \
            --header "Content-Type: application/json" \
            --data @-
