name: Artwork to AR (GLB + USDZ)

on:
  repository_dispatch:
    types: [canvasizer_trigger]

permissions:
  contents: write  # allow pushes to main

jobs:
  build-ar:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Blender
        run: brew install --cask blender

      - name: Download artwork
        run: |
          mkdir -p assets scripts output
          curl -L "${{ github.event.client_payload.image_url }}" -o assets/artwork.png

      - name: Preflight debug
        run: |
          set -euxo pipefail
          pwd
          ls -la
          echo "Tree before conversion:"
          find . -maxdepth 3 -type f

      - name: Create Blender script
        run: |
          cat > scripts/make_ar_plane.py << 'PY'
          import bpy
          import os
          import math
          
          # === ENV + VALIDATION ===
          img_path  = os.environ.get("ARIP_IMAGE_PATH")
          out_glb   = os.environ.get("ARIP_OUT_GLB")
          out_usdz  = os.environ.get("ARIP_OUT_USDZ")
          thickness_m = 0.02  # 2 cm
          
          print(f"üîç ARIP_IMAGE_PATH = {img_path}")
          print(f"üîç ARIP_OUT_GLB    = {out_glb}")
          print(f"üîç ARIP_OUT_USDZ   = {out_usdz}")
          
          if not img_path or not os.path.exists(img_path):
              raise FileNotFoundError(f"Image not found or ARIP_IMAGE_PATH unset: {img_path}")
          if not out_glb:
              raise ValueError("ARIP_OUT_GLB not set")
          if not out_usdz:
              print("‚ö†Ô∏è ARIP_OUT_USDZ not set; will skip USDZ export")
          
          os.makedirs(os.path.dirname(out_glb), exist_ok=True)
          if out_usdz:
              os.makedirs(os.path.dirname(out_usdz), exist_ok=True)
          
          # === CLEAN SCENE ===
          if bpy.ops.object.mode_set.poll():
              bpy.ops.object.mode_set(mode='OBJECT')
          bpy.ops.object.select_all(action='SELECT')
          bpy.ops.object.delete(use_global=False, confirm=False)
          
          # === LOAD IMAGE + ASPECT ===
          img = bpy.data.images.load(img_path)
          w, h = img.size
          if not w or not h:
              raise RuntimeError("Loaded image has invalid dimensions")
          aspect = w / h  # width:height
          
          # === BUILD PANEL (plane + solidify) ===
          # Start with a 1√ó1 plane in XY, UVs default to 0..1.
          bpy.ops.mesh.primitive_plane_add(size=1, enter_editmode=False)
          panel = bpy.context.active_object
          panel.name = "CanvasPanel"
          
          # Scale to match aspect: make height = 1.0 m, width = aspect m
          # Using dimensions is straightforward and applies scale correctly.
          panel.dimensions = (aspect, 1.0, 0.0)
          
          # Rotate -90¬∞ around X so front faces +Y (upright panel)
          panel.rotation_euler[0] = math.radians(-90)
          bpy.ops.object.transform_apply(location=False, rotation=True, scale=True)
          
          # Solidify to thickness along Y
          solid = panel.modifiers.new(name="Solidify", type='SOLIDIFY')
          solid.thickness = thickness_m
          solid.offset = 0.0  # thicken equally around the mid-plane
          solid.use_rim = True
          bpy.ops.object.modifier_apply(modifier=solid.name)
          
          # Ensure normals consistent (outward)
          bpy.ops.object.mode_set(mode='EDIT')
          bpy.ops.mesh.normals_make_consistent(inside=False)
          bpy.ops.object.mode_set(mode='OBJECT')
          
          # === MATERIALS ===
          # Front: textured. Sides/back: white.
          mat_tex = bpy.data.materials.new(name="CanvasFront")
          mat_tex.use_nodes = True
          nodes = mat_tex.node_tree.nodes
          links = mat_tex.node_tree.links
          for n in list(nodes): nodes.remove(n)
          out_node = nodes.new("ShaderNodeOutputMaterial")
          bsdf = nodes.new("ShaderNodeBsdfPrincipled")
          tex = nodes.new("ShaderNodeTexImage")
          tex.image = img
          links.new(tex.outputs["Color"], bsdf.inputs["Base Color"])
          links.new(bsdf.outputs["BSDF"], out_node.inputs["Surface"])
          
          mat_white = bpy.data.materials.new(name="CanvasSides")
          mat_white.use_nodes = True
          wnodes = mat_white.node_tree.nodes
          wlinks = mat_white.node_tree.links
          for n in list(wnodes): wnodes.remove(n)
          wout = wnodes.new("ShaderNodeOutputMaterial")
          wbsdf = wnodes.new("ShaderNodeBsdfPrincipled")
          wbsdf.inputs["Base Color"].default_value = (1.0, 1.0, 1.0, 1.0)
          wbsdf.inputs["Roughness"].default_value = 0.6
          wlinks.new(wbsdf.outputs["BSDF"], wout.inputs["Surface"])
          
          panel.data.materials.clear()
          panel.data.materials.append(mat_tex)    # slot 0
          panel.data.materials.append(mat_white)  # slot 1
          
          # Assign front faces (normal ~ +Y) to textured; others to white
          mesh = panel.data
          mesh.calc_normals()
          for poly in mesh.polygons:
              # dot with +Y
              if poly.normal.y > 0.999:  # very close to +Y
                  poly.material_index = 0
              else:
                  poly.material_index = 1
          
          # UVs: plane already has 0..1 UV on the front; ensure UV layer exists
          if not mesh.uv_layers:
              mesh.uv_layers.new(name="UVMap")
          
          print("‚úÖ Canvas built: upright, aspect-correct, white sides")
          
          # === EXPORTS ===
          print(f"‚úÖ Exporting GLB to: {out_glb}")
          bpy.ops.export_scene.gltf(
              filepath=out_glb,
              export_format='GLB',
              export_image_format='AUTO',
              export_yup=True,
              export_apply=True,
              export_texcoords=True,
              export_normals=True,
              export_materials='EXPORT',
              use_selection=False
          )
          print("‚úÖ GLB export complete")
          
          # USDZ (best-effort)
          if out_usdz:
              try:
                  if hasattr(bpy.ops.wm, "usd_export"):
                      print(f"‚úÖ Exporting USDZ to: {out_usdz}")
                      bpy.ops.wm.usd_export(
                          filepath=out_usdz,
                          export_materials=True,
                          export_textures=True,
                          selected_objects_only=False
                      )
                      print("‚úÖ USDZ export complete")
                  else:
                      print("‚ö†Ô∏è USD exporter not available in this Blender build; skipping USDZ")
              except Exception as e:
                  print(f"‚ö†Ô∏è USDZ export failed: {e}; continuing with GLB only")
          PY

      - name: Run Blender headless
        env:
          ARIP_IMAGE_PATH: ${{ github.workspace }}/assets/artwork.png
          ARIP_OUT_GLB:   ${{ github.workspace }}/output/artwork.glb
          ARIP_OUT_USDZ:  ${{ github.workspace }}/output/artwork.usdz
        run: /Applications/Blender.app/Contents/MacOS/Blender -b -noaudio --python scripts/make_ar_plane.py

      - name: Inspect post‚ÄëBlender output
        run: |
          set -euxo pipefail
          echo "Tree after Blender:"
          find . -maxdepth 4 -type f

      - name: Normalize and stage artifacts
        run: |
          set -euxo pipefail
          mkdir -p public_models
          shopt -s nullglob nocaseglob
          files=(output/*.{glb,usdz})
          if [ ${#files[@]} -eq 0 ]; then
            echo "‚ùå No 3D model files produced ‚Äî aborting"
            exit 1
          fi
          for f in "${files[@]}"; do
            base=$(basename "$f")
            lower=$(echo "$base" | tr '[:upper:]' '[:lower:]')
            cp -v "$f" "public_models/$lower"
          done
          ls -la public_models

      - name: Upload AR artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artwork-ar
          path: public_models/*

      - name: Commit artifacts to repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add public_models
          git commit -m "Add AR models for ${{ github.event.client_payload.title }}" || echo "No changes to commit"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

      - name: POST back to WordPress (after HEAD check)
        env:
          WP_WEBHOOK_URL: ${{ secrets.WP_WEBHOOK_URL }}
          WP_WEBHOOK_TOKEN: ${{ secrets.WP_WEBHOOK_TOKEN }}
        run: |
          GLB_PATH="public_models/artwork.glb"
          USDZ_PATH="public_models/artwork.usdz"

          GLB_URL=""
          USDZ_URL=""

          if [ -f "$GLB_PATH" ]; then
            GLB_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/$GLB_PATH"
          fi
          if [ -f "$USDZ_PATH" ]; then
            USDZ_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/$USDZ_PATH"
          fi

          echo "Will POST with:"
          echo "GLB: $GLB_URL"
          echo "USDZ: $USDZ_URL"

          # Wait until at least the GLB is live on GitHub's raw CDN
          # Max 30s, check every 3s
          for i in {1..10}; do
            if curl -s -I "$GLB_URL" | grep -q "200 OK"; then
              echo "‚úÖ GLB is live"
              break
            fi
            echo "‚è≥ Waiting for GLB to propagate..."
            sleep 3
          done

          # Optional: also wait for USDZ if present
          if [ -n "$USDZ_URL" ]; then
            for i in {1..10}; do
              if curl -s -I "$USDZ_URL" | grep -q "200 OK"; then
                echo "‚úÖ USDZ is live"
                break
              fi
              echo "‚è≥ Waiting for USDZ to propagate..."
              sleep 3
            done
          fi

          echo "POSTing to: $WP_WEBHOOK_URL"

          jq -n \
            --arg post_id  "${{ github.event.client_payload.post_id }}" \
            --arg title    "${{ github.event.client_payload.title }}" \
            --arg image    "${{ github.event.client_payload.image_url }}" \
            --arg glb      "$GLB_URL" \
            --arg usdz     "$USDZ_URL" \
            '{post_id:$post_id, title:$title, image_url:$image, glb_url:$glb, usdz_url:$usdz}' \
          | curl -v -X POST "$WP_WEBHOOK_URL" \
              -H "Authorization: Bearer $WP_WEBHOOK_TOKEN" \
              -H "Content-Type: application/json" \
              -d @-
