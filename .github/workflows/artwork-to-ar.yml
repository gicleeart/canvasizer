name: Artwork to AR (GLB + USDZ)

on:
  repository_dispatch:
    types: [canvasizer_trigger]

permissions:
  contents: write # allow pushes to main

jobs:
  build-ar:
    runs-on: macos-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Blender
        id: cache-blender
        uses: actions/cache@v3
        with:
          path: blender
          key: blender-macos-3.6.5

      - name: Download Blender if not cached
        if: steps.cache-blender.outputs.cache-hit != 'true'
        run: |
          mkdir -p blender
          echo "‚¨áÔ∏è Downloading Blender..."
          curl -L https://mirror.clarkson.edu/blender/release/Blender3.6/blender-3.6.5-macos-x64.dmg -o blender/blender.dmg
          hdiutil attach blender/blender.dmg -mountpoint /Volumes/Blender
          cp -R "/Volumes/Blender/Blender.app" blender/
          hdiutil detach /Volumes/Blender

      - name: Download artwork
        run: |
          mkdir -p assets scripts output
          curl -L "${{ github.event.client_payload.image_url }}" -o assets/artwork.png

      - name: Create Blender script
        run: |
          cat > scripts/make_ar_plane.py << 'PY'
          import bpy, os, math, sys, traceback

          def run():
              # --- Setup ---
              img_path = os.environ["ARIP_IMAGE_PATH"]
              out_glb  = os.environ["ARIP_OUT_GLB"]
              out_usdz = os.environ["ARIP_OUT_USDZ"]

              if not os.path.exists(img_path):
                  print(f"‚ùå ERROR: Input image not found at {img_path}")
                  sys.exit(1)

              os.makedirs(os.path.dirname(out_glb), exist_ok=True)
              bpy.ops.wm.read_factory_settings(use_empty=True)

              # --- Image and Dimensions ---
              print(f"üñºÔ∏è Loading image: {img_path}")
              img = bpy.data.images.load(img_path)
              img.pack()
              img.colorspace_settings.name = "sRGB"
              
              aspect = (img.size[0] / img.size[1]) if img.size[1] else 1.0
              width_m = 1.50
              depth_m = 0.02
              height_m = width_m / aspect
              print(f"üìê Dimensions: {width_m:.2f}m x {height_m:.2f}m x {depth_m:.2f}m")

              # --- Create and Shape the Panel Object ---
              bpy.ops.mesh.primitive_plane_add(size=1.0, enter_editmode=False, location=(0, 0, 0))
              panel = bpy.context.active_object
              panel.name = "ArtPanel"

              mod = panel.modifiers.new(name="Solidify", type='SOLIDIFY')
              mod.thickness = depth_m
              mod.offset = 1.0
              bpy.ops.object.modifier_apply(modifier=mod.name)

              panel.scale = (width_m / 2.0, height_m / 2.0, 1.0)
              bpy.ops.object.transform_apply(scale=True)
              panel.rotation_euler[0] = math.radians(90)
              bpy.ops.object.transform_apply(rotation=True)

              # --- Precise UV Unwrapping ---
              print("üîß Unwrapping UVs...")
              bpy.context.view_layer.objects.active = panel
              bpy.ops.object.mode_set(mode='EDIT')
              bpy.ops.mesh.select_all(action='SELECT')
              bpy.ops.uv.unwrap()
              bpy.ops.object.mode_set(mode='OBJECT')

              # --- Materials ---
              mesh = panel.data
              mat_front = bpy.data.materials.new("FrontArt")
              mat_front.use_nodes = True
              f_bsdf = mat_front.node_tree.nodes.get("Principled BSDF")
              f_tex = mat_front.node_tree.nodes.new("ShaderNodeTexImage")
              f_tex.image = img
              
              # --- FIX for USDZ Texture ---
              uv_map_node = mat_front.node_tree.nodes.new("ShaderNodeUVMap")
              uv_map_node.uv_map = mesh.uv_layers.active.name
              mat_front.node_tree.links.new(uv_map_node.outputs["UV"], f_tex.inputs["Vector"])

              mat_front.node_tree.links.new(f_tex.outputs["Color"], f_bsdf.inputs["Base Color"])
              f_bsdf.inputs["Roughness"].default_value = 0.7

              mat_side = bpy.data.materials.new("SideMat")
              mat_side.use_nodes = True
              s_bsdf = mat_side.node_tree.nodes.get("Principled BSDF")
              s_bsdf.inputs["Base Color"].default_value = (0.8, 0.8, 0.8, 1.0)
              s_bsdf.inputs["Roughness"].default_value = 0.9

              mesh.materials.append(mat_front)
              mesh.materials.append(mat_side)

              for poly in mesh.polygons:
                  poly.material_index = 1
              
              front_face = max(mesh.polygons, key=lambda p: p.center.y)
              front_face.material_index = 0

              # --- FINAL FIX for Image Rotation ---
              print("üîÑ Correcting UV rotation...")
              uv_layer = mesh.uv_layers.active.data
              for loop_index in front_face.loop_indices:
                  # Read original UV coordinate
                  original_uv = uv_layer[loop_index].uv[:]
                  # Apply 90-degree clockwise rotation: (u,v) -> (v, 1-u)
                  uv_layer[loop_index].uv.x = original_uv[1]
                  uv_layer[loop_index].uv.y = 1.0 - original_uv[0]

              # --- Export Files ---
              print("‚úÖ Object setup complete. Exporting files...")
              bpy.ops.export_scene.gltf(filepath=out_glb, export_format='GLB', export_yup=True, export_apply=True)
              print(f"‚úÖ GLB exported to {out_glb}")

              bpy.ops.wm.usd_export(filepath=out_usdz, selected_objects_only=False, export_textures=True)
              print(f"‚úÖ USDZ exported to {out_usdz}")

          # --- Main execution with error handling ---
          try:
              run()
              print("üéâ Script finished successfully.")
          except Exception as e:
              print("‚ùå An error occurred during Blender script execution:")
              traceback.print_exc()
              sys.exit(1)
          PY

      - name: Upload AR artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artwork-ar
          path: public_models/*    
          
      - name: Run Blender headless
        env:
          ARIP_IMAGE_PATH: ${{ github.workspace }}/assets/artwork.png
          ARIP_OUT_GLB: ${{ github.workspace }}/output/artwork.glb
          ARIP_OUT_USDZ: ${{ github.workspace }}/output/artwork.usdz
        run: blender/blender.app/Contents/MacOS/Blender -b -noaudio --python scripts/make_ar_plane.py

      - name: Inspect post-Blender output
        if: always() # Run this step even if Blender fails
        run: |
          echo "üå≤ Tree after Blender:"
          find . -maxdepth 4 -type f

      - name: Normalize and stage artifacts
        run: |
          mkdir -p public_models
          shopt -s nullglob nocaseglob
          files=(output/*.{glb,usdz})
          if [ ${#files[@]} -eq 0 ]; then
            echo "‚ùå No 3D model files were produced by Blender."
            exit 1
          fi
          for f in "${files[@]}"; do
            base=$(basename "$f")
            lower=$(echo "$base" | tr '[:upper:]' '[:lower:]')
            cp -v "$f" "public_models/$lower"
          done
          echo "‚úÖ Artifacts staged:"
          ls -la public_models

      - name: Upload AR artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artwork-ar
          path: public_models/*    

      - name: Commit artifacts to repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add public_models
          # Check if there's anything to commit
          if git diff-index --quiet HEAD --; then
            echo "No changes to commit."
          else
            git commit -m "Add AR models for ${{ github.event.client_payload.title }}"
            git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          fi

      - name: POST back to WordPress
        env:
          WP_WEBHOOK_URL: ${{ secrets.WP_WEBHOOK_URL }}
          WP_WEBHOOK_TOKEN: ${{ secrets.WP_WEBHOOK_TOKEN }}
        run: |
          GLB_PATH="public_models/artwork.glb"
          USDZ_PATH="public_models/artwork.usdz"

          GLB_URL=""
          USDZ_URL=""

          if [ -f "$GLB_PATH" ]; then
            GLB_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/$GLB_PATH"
          fi
          if [ -f "$USDZ_PATH" ]; then
            USDZ_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/$USDZ_PATH"
          fi

          # Wait up to 30s for the main artifact (GLB) to be live on GitHub's CDN
          echo "‚è≥ Waiting for GLB to become available at $GLB_URL..."
          for i in {1..10}; do
            if curl --output /dev/null --silent --head --fail "$GLB_URL"; then
              echo "‚úÖ GLB is live."
              break
            fi
            sleep 3
          done

          echo "POSTing results to WordPress webhook..."
          jq -n \
            --arg post_id  "${{ github.event.client_payload.post_id }}" \
            --arg title    "${{ github.event.client_payload.title }}" \
            --arg image    "${{ github.event.client_payload.image_url }}" \
            --arg glb      "$GLB_URL" \
            --arg usdz     "$USDZ_URL" \
            '{post_id:$post_id, title:$title, image_url:$image, glb_url:$glb, usdz_url:$usdz}' \
          | curl -v -X POST "$WP_WEBHOOK_URL" \
              -H "Authorization: Bearer $WP_WEBHOOK_TOKEN" \
              -H "Content-Type: application/json" \
              -d @-
