name: Artwork to AR (GLB + USDZ)

on:
  repository_dispatch:
    types: [canvasizer_trigger]

permissions:
  contents: write  # allow pushes to main

jobs:
  build-ar:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Blender
        run: brew install --cask blender

      - name: Download artwork
        run: |
          mkdir -p assets scripts output
          curl -L "${{ github.event.client_payload.image_url }}" -o assets/artwork.png

      - name: Preflight debug
        run: |
          set -euxo pipefail
          pwd
          ls -la
          echo "Tree before conversion:"
          find . -maxdepth 3 -type f

      - name: Create Blender script
        run: |
          cat > scripts/make_ar_plane.py << 'PY'
          import bpy, os, bmesh

          # === Env paths ===
          img_path = os.environ["ARIP_IMAGE_PATH"]
          out_glb  = os.environ["ARIP_OUT_GLB"]
          out_usdz = os.environ["ARIP_OUT_USDZ"]
          
          # Ensure dirs exist
          os.makedirs(os.path.dirname(out_glb), exist_ok=True)
          os.makedirs(os.path.dirname(out_usdz), exist_ok=True)
          
          # Clean scene
          bpy.ops.wm.read_factory_settings(use_empty=True)
          
          # === Panel dimensions ===
          width_m = 1.00     # 1 m wide
          depth_m = 0.01     # 1 cm thick
          
          # Load image and compute aspect
          img = bpy.data.images.load(img_path)
          img.colorspace_settings.name = "sRGB"
          aspect = (img.size[0] / img.size[1]) if img.size[1] else 1.0
          height_m = width_m / aspect
          
          # === Create front plane at origin ===
          bpy.ops.mesh.primitive_plane_add(size=1.0, enter_editmode=False)
          panel = bpy.context.active_object
          panel.name = "ArtPanel"
          
          # Scale to real size
          panel.scale = (width_m / 2.0, height_m / 2.0, 1.0)
          bpy.ops.object.transform_apply(scale=True, rotation=False, location=False)
          
          # Solidify for thickness (push back so front stays at z=0)
          mod = panel.modifiers.new(name="Solidify", type='SOLIDIFY')
          mod.thickness = depth_m
          mod.offset = -1.0
          bpy.ops.object.modifier_apply(modifier=mod.name)
          
          mesh = panel.data
          
          # === Ensure UV layer exists ===
          if not mesh.uv_layers:
              mesh.uv_layers.new(name="UVMap")
          
          # === Materials ===
          mat_front = bpy.data.materials.new("FrontArt")
          mat_front.use_nodes = True
          f_bsdf = mat_front.node_tree.nodes.get("Principled BSDF")
          f_tex = mat_front.node_tree.nodes.new("ShaderNodeTexImage")
          f_tex.image = img
          f_tex.interpolation = "Smart"
          f_tex.extension = "CLIP"
          mat_front.node_tree.links.new(f_tex.outputs["Color"], f_bsdf.inputs["Base Color"])
          f_bsdf.inputs["Roughness"].default_value = 0.7
          f_bsdf.inputs["Metallic"].default_value = 0.0
          
          mat_side = bpy.data.materials.new("SideMat")
          mat_side.use_nodes = True
          s_bsdf = mat_side.node_tree.nodes.get("Principled BSDF")
          s_bsdf.inputs["Base Color"].default_value = (1.0, 1.0, 1.0, 1.0)
          s_bsdf.inputs["Roughness"].default_value = 0.9
          s_bsdf.inputs["Metallic"].default_value = 0.0
          
          # Assign slots 0 and 1
          mesh.materials.clear()
          mesh.materials.append(mat_front)
          mesh.materials.append(mat_side)
          
          # Default all to side material
          for poly in mesh.polygons:
              poly.material_index = 1
          
          # === bmesh for face/UV assignment ===
          bm = bmesh.new()
          bm.from_mesh(mesh)
          bm.faces.ensure_lookup_table()
          
          # Identify front face: largest with +Z normal
          front_face = None
          max_area = 0
          for f in bm.faces:
              if f.normal.z > 0.5 and f.calc_area() > max_area:
                  max_area = f.calc_area()
                  front_face = f
          if not front_face:
              front_face = max(bm.faces, key=lambda f: f.calc_center_median().z)
          
          front_face.material_index = 0
          
          # Normalize UVs to front face
          xs = [v.co.x for v in front_face.verts]
          ys = [v.co.y for v in front_face.verts]
          min_x, max_x = min(xs), max(xs)
          min_y, max_y = min(ys), max(ys)
          dx = (max_x - min_x) or 1.0
          dy = (max_y - min_y) or 1.0
          
          if not bm.loops.layers.uv:
              bm.loops.layers.uv.new()
          uv_lay = bm.loops.layers.uv.active
          
          for loop in front_face.loops:
              uv = loop[uv_lay].uv
              uv.x = (loop.vert.co.x - min_x) / dx
              uv.y = (loop.vert.co.y - min_y) / dy
          
          bm.to_mesh(mesh)
          bm.free()
          
          # === Ensure scene updates ===
          bpy.context.view_layer.update()
          
          # === Export GLB (embedded textures) ===
          bpy.ops.export_scene.gltf(
              filepath=out_glb,
              export_format='GLB',
              export_embed_images=True
          )
          
          # === Export USDZ ===
          bpy.ops.wm.usd_export(
              filepath=out_usdz,
              export_textures=True
          )
          
          print("✅ AR panel exported to:")
          print("   GLB :", out_glb)
          print("   USDZ:", out_usdz)

          PY

      - name: Run Blender headless
        env:
          ARIP_IMAGE_PATH: ${{ github.workspace }}/assets/artwork.png
          ARIP_OUT_GLB:   ${{ github.workspace }}/output/artwork.glb
          ARIP_OUT_USDZ:  ${{ github.workspace }}/output/artwork.usdz
        run: /Applications/Blender.app/Contents/MacOS/Blender -b -noaudio --python scripts/make_ar_plane.py

      - name: Inspect post‑Blender output
        run: |
          set -euxo pipefail
          echo "Tree after Blender:"
          find . -maxdepth 4 -type f

      - name: Normalize and stage artifacts
        run: |
          set -euxo pipefail
          mkdir -p public_models
          shopt -s nullglob nocaseglob
          files=(output/*.{glb,usdz})
          if [ ${#files[@]} -eq 0 ]; then
            echo "❌ No 3D model files produced — aborting"
            exit 1
          fi
          for f in "${files[@]}"; do
            base=$(basename "$f")
            lower=$(echo "$base" | tr '[:upper:]' '[:lower:]')
            cp -v "$f" "public_models/$lower"
          done
          ls -la public_models

      - name: Upload AR artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artwork-ar
          path: public_models/*

      - name: Commit artifacts to repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add public_models
          git commit -m "Add AR models for ${{ github.event.client_payload.title }}" || echo "No changes to commit"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git

      - name: POST back to WordPress (after HEAD check)
        env:
          WP_WEBHOOK_URL: ${{ secrets.WP_WEBHOOK_URL }}
          WP_WEBHOOK_TOKEN: ${{ secrets.WP_WEBHOOK_TOKEN }}
        run: |
          GLB_PATH="public_models/artwork.glb"
          USDZ_PATH="public_models/artwork.usdz"

          GLB_URL=""
          USDZ_URL=""

          if [ -f "$GLB_PATH" ]; then
            GLB_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/$GLB_PATH"
          fi
          if [ -f "$USDZ_PATH" ]; then
            USDZ_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/$USDZ_PATH"
          fi

          echo "Will POST with:"
          echo "GLB: $GLB_URL"
          echo "USDZ: $USDZ_URL"

          # Wait until at least the GLB is live on GitHub's raw CDN
          # Max 30s, check every 3s
          for i in {1..10}; do
            if curl -s -I "$GLB_URL" | grep -q "200 OK"; then
              echo "✅ GLB is live"
              break
            fi
            echo "⏳ Waiting for GLB to propagate..."
            sleep 3
          done

          # Optional: also wait for USDZ if present
          if [ -n "$USDZ_URL" ]; then
            for i in {1..10}; do
              if curl -s -I "$USDZ_URL" | grep -q "200 OK"; then
                echo "✅ USDZ is live"
                break
              fi
              echo "⏳ Waiting for USDZ to propagate..."
              sleep 3
            done
          fi

          echo "POSTing to: $WP_WEBHOOK_URL"

          jq -n \
            --arg post_id  "${{ github.event.client_payload.post_id }}" \
            --arg title    "${{ github.event.client_payload.title }}" \
            --arg image    "${{ github.event.client_payload.image_url }}" \
            --arg glb      "$GLB_URL" \
            --arg usdz     "$USDZ_URL" \
            '{post_id:$post_id, title:$title, image_url:$image, glb_url:$glb, usdz_url:$usdz}' \
          | curl -v -X POST "$WP_WEBHOOK_URL" \
              -H "Authorization: Bearer $WP_WEBHOOK_TOKEN" \
              -H "Content-Type: application/json" \
              -d @-
